新标签
	新的语义化标签
		nav footer header article section
	新的音视频标签
		video audio  存在格式兼容问题

API
	Geolocation
		使用很简单，请求位置信息，需经用户同意，浏览器会返回一个位置信息，
		该位置是通过用户的底层设备（手机，电脑），提供给浏览器。
		位置信息一般包括经度和纬度信息，有两种表示方式：
			a、十进制表示:39.17222
			b、DMS角度格式表示：39°10'20"

		html5 Geolocation API不指定设备使用哪种底层技术来定位应用程序的用户，相反，
		它只是用于检索位置信息的API，而且通过该API检索到的数据只具有某种程度的准确性！
		它并不能保证设备返回的数据就是精确的。
		设备可以使用的数据源如下所示：
			IP地址
			三维坐标
			　　1、GPS（全球定位系统）
			　　2、从RFID、Wi-FI和蓝牙到Wi-FI的MAC地址
			　　3、GSM或CDMA手机的ID
			用户自定义数据

		检测
			if('geolocation' in navigator)

		使用
			navigator.geolocation.getCurrentPosition(successCallback[,failCallback,..]);

		navigator.geoposition.getCurrentPosition(successCallback,failCallback,options);
							 .watchPosition(successCallback,failCallback,options);//用户位置发生变化便会触发函数
			watchPosition 返回一个 watchId，可以通过navigator.geolocation.clearWatch(watchID);停止监测
		
			successCallback = function(position){}
			failCallback = function(error){}
				error.code:0 不详，查看error.message
						   1 PERMISSION_DENIED 用户拒绝
						   2 POSITION_UNVAILABLE 
						   3 TIMEOUT
			options：
				{
					enableHighAccuracy: true,   //是否需要高精度数据，可能时间较长，或许失败
					maximumAge        : 30000,  //浏览器重新计算位置的时间间隔，以ms为单位，默认为0
					timeout           : 27000   //超时时间
				}

	WebSocket  使得web可以实时接收浏览器响应
		因HTTP协议是一种无状态的、无连接的、单向的应用层协议，服务器无法向客户端发送信息。
		websocket全双工通信，连接长期存在，服务器开销很大。
			基于多进程或多线程的服务器无法适用websocket，websocket服务器应该是异步的。

		使用
			var Socket = new WebSocket(url, [protocol] ); //protocal表示子协议
			WebSocket对象属性
				readyState：
					0 连接尚未建立
					1 连接已建立，可以通信
					2 连接正在关闭
					3 连接已关闭或无法打开
				bufferedAmount
					只读，表示已被send()放入正在队列中等待传输，但是还没有发出的UTF-8文本字节数。
			WebSocket事件
				open 	连接建立时触发
				message 客户端收到服务器数据时触发
				error   通信发生错误时触发
				close   连接关闭时触发
			WebSocket方法
				socket.send();  //发送数据
				socket.close();

			完整流程
				// 初始化一个 WebSocket 对象
				var ws = new WebSocket("ws://localhost:9998/echo");
				// 建立 web socket 连接成功触发事件
				ws.onopen = function () {
					// 使用 send() 方法发送数据
					ws.send("发送数据");
					alert("数据发送中...");
				};
				// 接收服务端数据时触发事件
				ws.onmessage = function (evt) {
					var received_msg = evt.data;
					alert("数据已接收...");
				};
				// 断开 web socket 连接成功触发事件
				ws.onclose = function () {
					console.log("连接已关闭...");
				};

	Communication
		跨文档消息传递，在同一窗口下的文档通信，如document & frame
			sender
				window.postMessage(content,url);
			receiver
				window.addEventListener('message',function(e){
					e.origin   //来源
					e.data     //数据
				},true);

		CORS  CROSS ORIGIN RESOURCE SHARING
			直接像ajax一样请求，服务端要同意跨域

	Form API
		setCustomValidity(); //自定义显示的错误信息
		checkValidity();  	 //强制要求对元素进行验证，它能够在不提交表单的前提下激活验证过程

		form 的 invalid 事件
			form提交时，如果检测到无效输入，会触发该事件
		...

	Webworkers
		当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。
		webworkers,是运行在后台的JavaScript，独立于其他脚本，不会影响页面的性能,不会阻塞页面。
		typeof(Worker) === 'undefined'
		var worker = new Worker('demo.js');//以代码创建Worker，
			demo.js代码中以postMessage传递数据,不能写window.postMessage
			无需将demo.js引入文档
			demo.js位于外部文档，无法使用document、window、parent
		worker.onmessage = function(e){
			e.data; //传递的数据
		}
		worker.terminate();  //终止worker

	Webstorage
		两种类型  Window.localStorage 和 Window.sessionStorage   2.5 MB - 10 MB之间
			localStorage 持久化的本地存储（浏览器关闭重新打开数据依然存在）
			sessionStorage 针对一个session的本地存储
		优势
			比cookie容量更大
			可以将请求的表单数据存于本地，减少http请求，节约带宽
			webStorage拥有易用的API
		局限性
			不同浏览器SessionStorage 和LocalStorage的大小不统一。
			在浏览器的隐私模式下面是不可读取的
			本质上是对字符串的读取，因此存储内容过多时页面会变卡
			不能被爬虫抓取到
		使用
			存储
				localStorage.name = 'value';
			　　localStorage['name'] = 'value';
			　　localStorage.setItem('name','value');
				键值总是字符串
			获取
				var value = localStorage.name;
				var value = localStorage['name'];
				var value = localStorage.getItem('name');
			删除
				localStorage.clear(); //清空
				localStorage.removeItem('name');//删除指定键值对
		检测支持性
			function storageAvailable(type) {
		　　　　try {
		　　　　　　var storage = window[type],
		　　　　　　x = '__storage_test__';
		　　　　　　storage.setItem(x, x);
		　　　　　　storage.removeItem(x);
		　　　　　　return true;
		　　　　}
		　　　　catch(e) {
		　　　　　　return false;
		　　　　}
		　　}
		　　if (storageAvailable('localStorage')) {
		　　　　// do something here 
		　　}
		　　else {
		　　　　// Too bad, no localStorage for us
		　　}

	IndexedDB
		简介
			cookie 4kb  storage 2.5MB-10MB
			IndexedDB是浏览器本地数据库，可以用JS创建和操作。
			IndexedDB 允许储存大量数据，提供查找接口，还能建立索引，属于非关系型数据库
		特点
			键值对存储
				键必须唯一，值可以为js任意数据类型
			异步
				IndexedDB操作是异步的，不会阻塞浏览器。与storage不同，storage是同步的。
			支持事务  transation
				一系列操作步骤之中，只要有一步失败，整个事务就都取消，
				数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。
			同源限制
				浏览器仅能访问本域名下创建的数据库，不能跨域访问。
			存储空间大
				不少于250MB，甚至没有上限。
			支持二进制存储
				可以存储二进制数据。 ArrayBuffer 对象和 Blob 对象
		基本概念
			数据库：IDBDatabase 对象
				一系列相关数据的容器，每个域(协议+域名+端口)可以创建多个数据库。
			对象仓库：IDBObjectStore 对象  
				数据库中可以有多个仓库，类似SQL的table
			索引： IDBIndex 对象
				为了加速数据的检索，可以在对象仓库里面，为不同的属性建立索引。
			事务： IDBTransaction 对象
				数据变更，都要通过事务完成。事务对象提供error、abort和complete三个事件，用来监听操作结果。
			操作请求：IDBRequest 对象
			指针： IDBCursor 对象
			主键集合：IDBKeyRange 对象
		操作
			打开数据库
				var dbr = window.indexedDB.open(databaseName, version);
					打开databaseName，没有则创建。version可省略，默认为当前版本，或新建时，默认为1。
					返回一个IDBRequest对象
				事件
					error  //打开失败
						dbr.onerror = function(){}
					success 
						dbr.onsuccess = function(e){
							var db = dbr.result;//数据库实例
						}
					upgradeneeded
						如果指定版本号，大于数据库当前版本号，就会触发数据库升级事件
						dbr.onupgradeneeded = function(e){
							var db = e.target.result; //当前数据库实例
						}
			新建数据库，打开一个不存在的数据库即会出发新建，后续操作主要在upgradeneeded时间内完成
				dbr.onupgradeneeded = function(e) {
					db = e.target.result;
					var objectStore = db.createObjectStore('person', { keyPath: 'id' }); //创建仓库，指定主键
				}
				最好先判断仓库是否存在，再创建
				dbr.onupgradeneeded = function (event) {
					var db = event.target.result;
					var objectStore;
					if (!db.objectStoreNames.contains('person')) {
						objectStore = db.createObjectStore('person', { keyPath: 'id' });
					}
				}
				主键是默认建立的索引属性，可指定为下一层对象的属性，如{ foo: { bar: 'baz' } }的foo.bar也可以指定为主键
				主键可以指定为默认自增
					var objectStore = db.createObjectStore(
						'person',
						{ autoIncrement: true }
					);

				创建仓库后，下一步可以创建索引
					objectStore.createIndex('name', 'name', { unique: false });
  					objectStore.createIndex('email', 'email', { unique: true });
  						三个参数  索引名称  索引所在的属性  配置对象(是否包含重复值)
  			新增数据		需要使用事务
  				function add() {
					var request = db.transaction(['person'], 'readwrite')
									.objectStore('person')
									.add({ id: 1, name: '张三', age: 24, email: 'zhangsan@example.com' });

					request.onsuccess = function (event) {
						console.log('数据写入成功');
					};

					request.onerror = function (event) {
						console.log('数据写入失败');
					}
				}

				add();
			读取数据  也要通过事务  //根据主键读取
				function read() {
				   var transaction = db.transaction(['person']);
				   var objectStore = transaction.objectStore('person');
				   var request = objectStore.get(1);

				   request.onerror = function(event) {
				     console.log('事务失败');
				   };

				   request.onsuccess = function( event) {
				      if (request.result) {
				        console.log('Name: ' + request.result.name);
				        console.log('Age: ' + request.result.age);
				        console.log('Email: ' + request.result.email);
				      } else {
				        console.log('未获得数据记录');
				      }
				   };
				}

				read();
			遍历数据
				function readAll() {
				  var objectStore = db.transaction('person').objectStore('person');

				   objectStore.openCursor().onsuccess = function (event) {
				     var cursor = event.target.result;

				     if (cursor) {
				       console.log('Id: ' + cursor.key);
				       console.log('Name: ' + cursor.value.name);
				       console.log('Age: ' + cursor.value.age);
				       console.log('Email: ' + cursor.value.email);
				       cursor.continue();
				    } else {
				      console.log('没有更多数据了！');
				    }
				  };
				}

				readAll();
			更新数据
				function update() {
				  var request = db.transaction(['person'], 'readwrite')
				    .objectStore('person')
				    .put({ id: 1, name: '李四', age: 35, email: 'lisi@example.com' });

				  request.onsuccess = function (event) {
				    console.log('数据更新成功');
				  };

				  request.onerror = function (event) {
				    console.log('数据更新失败');
				  }
				}

				update();
			删除数据
				function remove() {
				  var request = db.transaction(['person'], 'readwrite')
								  .objectStore('person')
								  .delete(1);

				  request.onsuccess = function (event) {
				    console.log('数据删除成功');
				  };
				}

				remove();
			使用索引
				objectStore.createIndex('name', 'name', { unique: false });
				var transaction = db.transaction(['person'], 'readonly');
				var store = transaction.objectStore('person');
				var index = store.index('name');
				var request = index.get('李四');

				request.onsuccess = function (e) {
				  var result = e.target.result;
				  if (result) {
				    // ...
				  } else {
				    // ...
				  }
				}

